// ===================================
// Main.cpp file generated by OptFrame
// Project HFMVRP
// ===================================

#include <iostream>
#include <math.h>
#include <stdlib.h>

#include "../OptFrame/CloneConstructive.hpp"
#include "../OptFrame/Heuristics/Empty.hpp"
#include "../OptFrame/Heuristics/EvolutionaryAlgorithms/ESContinuous.hpp"
#include "../OptFrame/Heuristics/EvolutionaryAlgorithms/NGES.hpp"
#include "../OptFrame/Heuristics/GRASP/BasicGRASP.hpp"
#include "../OptFrame/Heuristics/ILS/ILSLPerturbation.hpp"
#include "../OptFrame/Heuristics/ILS/IteratedLocalSearchLevels.hpp"
#include "../OptFrame/Heuristics/LocalSearches/BestImprovement.hpp"
#include "../OptFrame/Heuristics/LocalSearches/FirstImprovement.hpp"
#include "../OptFrame/Heuristics/LocalSearches/VariableNeighborhoodDescent.hpp"
#include "../OptFrame/Heuristics/LocalSearches/VariableNeighborhoodDescentUpdateADS.hpp"
#include "../OptFrame/NSSeq.hpp"
#include "../OptFrame/Timer.hpp"
#include "../OptFrame/Util/CheckCommand.hpp"
#include "../OptFrame/Util/RandGenMersenneTwister.hpp"
#include "HFMVRP.h"

using namespace std;

using namespace HFMVRP;

int
main(int argc, char** argv)
{
   cout << argv[0] << endl;
   RandGenMersenneTwister rg;
   long seed = time(NULL);
   seed = 100;
   cout << "Seed = " << seed << endl;
   srand(seed);
   rg.setSeed(seed);

   Timer walltimer;

   //srand(seed);

   if (argc != 7) {
      cout << "Parametros incorretos!" << endl;
      cout << "Os parametros esperados sao: nome tempo fo_alvo mutationRate mi batch" << endl;
      exit(1);
   }

   const char* caminho = argv[1];
   double tempo = atof(argv[2]);
   double fo_alvo = atof(argv[3]);
   double mutationRate = atof(argv[4]);
   int mi = atoi(argv[5]);
   int batch = atoi(argv[6]);

   string nome = caminho;

   cout << "Parametros:" << endl;
   cout << "nome=" << nome << endl;
   cout << "tempo=" << tempo << endl;
   cout << "fo_alvo=" << fo_alvo << endl;
   cout << "mutationRate=" << mutationRate << endl;
   cout << "mi=" << mi << endl;
   cout << "batch=" << batch << endl;

   Scanner scanner(new File(nome));

   ProblemInstance* p = new ProblemInstance(scanner);
   HFMVRPEvaluator* eval = new HFMVRPEvaluator(*p);
   HFMVRPADSManager* adsMan = new HFMVRPADSManager(*p);
   double alpha = 0;
   ConstructiveSavingsRandomized is(*p, rg, *adsMan);

   NSSeq<SolutionHFMVRP>* nsseq_deltaIterator_delta_2opt = new NSSeqVRP2Opt<int, AdsHFMVRP, SolutionHFMVRP, DeltaMoveVRP2Opt, ProblemInstance, DeltaNSIteratorVRP2Opt<DeltaMoveVRP2Opt>>(p);
   NSSeq<SolutionHFMVRP>* nsseq_deltaIterator_delta_or1 = new NSSeqVRPOrOpt1<int, AdsHFMVRP, SolutionHFMVRP, DeltaMoveVRPOrOpt1, ProblemInstance, DeltaNSIteratorVRPOrOpt1<DeltaMoveVRPOrOpt1>>(p);
   NSSeq<SolutionHFMVRP>* nsseq_deltaIterator_delta_or2 = new NSSeqVRPOrOpt2<int, AdsHFMVRP, SolutionHFMVRP, DeltaMoveVRPOrOpt2, ProblemInstance, DeltaNSIteratorVRPOrOpt2<DeltaMoveVRPOrOpt2>>(p);
   NSSeq<SolutionHFMVRP>* nsseq_deltaIterator_delta_exchange = new NSSeqVRPExchange<int, AdsHFMVRP, SolutionHFMVRP, DeltaMoveVRPExchange, ProblemInstance, DeltaNSIteratorVRPExchange<DeltaMoveVRPExchange>>(p);
   NSSeq<SolutionHFMVRP>* nsseq_delta_shift10 = new NSSeqVRPShift10<int, AdsHFMVRP, SolutionHFMVRP, DeltaMoveVRPShift10, ProblemInstance>(p);
   NSSeq<SolutionHFMVRP>* nsseq_delta_swap11 = new NSSeqVRPSwap1_1<int, AdsHFMVRP, SolutionHFMVRP, DeltaMoveVRPSwap1_1, ProblemInstance>(p);
   NSSeq<SolutionHFMVRP>* nsseq_deltaIterator_swap11 = new NSSeqVRPSwap1_1<int, AdsHFMVRP, SolutionHFMVRP, DeltaMoveVRPSwap1_1, ProblemInstance, DeltaNSIteratorVRPSwap1_1<DeltaMoveVRPSwap1_1>>(p);
   NSSeq<SolutionHFMVRP>* nsseq_deltaIterator_shift10 = new NSSeqVRPShift10<int, AdsHFMVRP, SolutionHFMVRP, DeltaMoveVRPShift10, ProblemInstance, DeltaNSIteratorVRPShift10<DeltaMoveVRPShift10>>(p);

   ILSLPerturbationLPlus2Prob<SolutionHFMVRP>* ilsl_pert;

   //ilsl_pert = new ILSLPerturbationLPlus2Prob<SolutionHFMVRP>(*eval, 100000, *nsseq_deltaIterator_shift10, rg);
   ilsl_pert = new ILSLPerturbationLPlus2Prob<SolutionHFMVRP>(*eval, *nsseq_deltaIterator_shift10, rg);
   ilsl_pert->add_ns(*nsseq_deltaIterator_swap11);
   ilsl_pert->add_ns(*nsseq_deltaIterator_delta_2opt);
   ilsl_pert->add_ns(*nsseq_deltaIterator_delta_or1);
   ilsl_pert->add_ns(*nsseq_deltaIterator_delta_or2);
   ilsl_pert->add_ns(*nsseq_deltaIterator_delta_exchange);
   int myints[] =
     { 3, 3, 1, 1, 1, 1 };
   vector<int> priorites(myints, myints + sizeof(myints) / sizeof(int));
   ilsl_pert->changeProb(priorites);

   vector<LocalSearch<SolutionHFMVRP>*> vLS;
   BestImprovement<SolutionHFMVRP> fiI(*eval, *nsseq_deltaIterator_delta_2opt);
   BestImprovement<SolutionHFMVRP> fiII(*eval, *nsseq_deltaIterator_delta_or1);
   BestImprovement<SolutionHFMVRP> fiIII(*eval, *nsseq_deltaIterator_delta_or2);
   BestImprovement<SolutionHFMVRP> fiIV(*eval, *nsseq_deltaIterator_delta_exchange);
   BestImprovement<SolutionHFMVRP> fiV(*eval, *nsseq_deltaIterator_swap11);
   BestImprovement<SolutionHFMVRP> fiVI(*eval, *nsseq_deltaIterator_shift10);
   vLS.push_back(&fiI);
   vLS.push_back(&fiII);
   vLS.push_back(&fiIII);
   vLS.push_back(&fiIV);
   vLS.push_back(&fiV);
   vLS.push_back(&fiVI);

   CheckCommand<RepHFMVRP, AdsHFMVRP, SolutionHFMVRP> cc;
   cc.add(*eval);
   //	cc.add(p);
   cc.add(is);
   cc.add(*nsseq_delta_shift10);
   cc.add(*nsseq_delta_swap11);
   cc.add(*nsseq_deltaIterator_swap11);
   cc.add(*nsseq_deltaIterator_shift10);
   cc.add(*nsseq_deltaIterator_delta_2opt);
   cc.add(*nsseq_deltaIterator_delta_or1);
   cc.add(*nsseq_deltaIterator_delta_or2);
   cc.add(*nsseq_deltaIterator_delta_exchange);
   cc.add(*adsMan);
   cc.run(1, 1);
   getchar();

   // if randgen is given, it is RVND
   VariableNeighborhoodDescent<SolutionHFMVRP> newVND(*eval, vLS, &rg);
   VariableNeighborhoodDescentUpdateADS<RepHFMVRP, AdsHFMVRP, SolutionHFMVRP> newVNDUpdateADS(*eval, *adsMan, vLS);
   BasicGRASP<SolutionHFMVRP> basicGrasp(*eval, is, newVNDUpdateADS, alpha, 1000);

   EmptyLocalSearch<SolutionHFMVRP> emptyLS;
   vector<NSSeq<SolutionHFMVRP>*> vNSeq;
   vNSeq.push_back(nsseq_deltaIterator_delta_2opt);
   vNSeq.push_back(nsseq_deltaIterator_delta_or1);
   vNSeq.push_back(nsseq_deltaIterator_delta_or2);
   vNSeq.push_back(nsseq_deltaIterator_delta_exchange);
   vNSeq.push_back(nsseq_deltaIterator_swap11);
   vNSeq.push_back(nsseq_deltaIterator_shift10);

   SOSC<> soscGR(10, Evaluation<>(0)); // target zero and 10 seconds
   std::optional<pair<SolutionHFMVRP, Evaluation<>>> initialPairGrasp;
   auto sflag = basicGrasp.search(initialPairGrasp, soscGR);

   CloneConstructive<SolutionHFMVRP> cloneSolAsConstructive(initialPairGrasp->first);

   vector<int> vNSeqMaxApplication(vNSeq.size(), 1000);
   int selectionType = 1;
   //	double mutationRate = 1;
   //	int mi = 5;
   //int batach = 5;

   // which ES?
   /*

   ES<SolutionHFMVRP> es(*eval, cloneSolAsConstructive, vNSeq, vNSeqMaxApplication, emptyLS, selectionType, mutationRate, rg, mi, 6 * mi, 50000, "./esOutput", batch);
   es.setMessageLevel(4);

   SOSC soscES(180, 0);
   pair<Solution<SolutionHFMVRP>, Evaluation<>>* initialSol = es.search(soscES);
   double objFuncES = initialSol->second.getObjFunction();
   cout << "getObjFunction: " << objFuncES << endl;
   */
   double objFuncES = 0; // which is this Vitor?

   size_t found = nome.find_last_of("/\\");
   string instanceName = nome.substr(found + 1);
   FILE* arquivo = fopen("./MyProjects/Results/log.txt", "a");
   if (!arquivo) {
      cout << "ERRO: falha ao criar arquivo \"./Results/log.txt\"" << endl;
   } else {
      fprintf(arquivo, "%s\t%f\t%f\t%d\t%d\t%ld\n", instanceName.c_str(), mutationRate, objFuncES, mi, batch, seed);
      fclose(arquivo);
   }

   /*	// ==================== BEGIN ILS AND GRASP ===========================
	 //pair<Solution<SolutionHFMVRP>&, Evaluation<>&>* initialPair = basicGrasp.search(30, 0);

	 CloneConstructive<SolutionHFMVRP> cloneSolAsConstructive(initialSol->first);
	 IteratedLocalSearchLevels<SolutionHFMVRP> ilsl(*eval, cloneSolAsConstructive, newVNDUpdateADS, *ilsl_pert, 130, 15);
	 ilsl.setMessageLevel(4);

   SOSC soscILSL(60,0);
	 pair<Solution<SolutionHFMVRP>, Evaluation<>>* pairILS = ilsl.search(soscILSL);
	 Solution<SolutionHFMVRP> ilsSOL = pairILS->first;

	 EvaluationHFMVRP value = eval->evaluate(ilsSOL.getR());
	 cout << "getObjFunction: " << value.getObjFunction() << endl;
	 cout << "getInfMeasure: " << value.getInfMeasure() << endl;
	 value.print();

	 eval->exportEXCEL(ilsSOL.getR(), "./MyProjects/Results/teste");*/

   cout << "Program ended successfully" << endl;

   return 0;
}
