// OptFrame - Optimization Framework

// Copyright (C) 2009-2015
// http://optframe.sourceforge.net/
//
// This file is part of the OptFrame optimization framework. This framework
// is free software; you can redistribute it and/or modify it under the
// terms of the GNU Lesser General Public License v3 as published by the
// Free Software Foundation.

// This framework is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License v3 for more details.

// You should have received a copy of the GNU Lesser General Public License v3
// along with this library; see the file COPYING.  If not, write to the Free
// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
// USA.

// ===================================
// Main.cpp file generated by OptFrame
// Project Traveling Salesman Problem
// ===================================

#include <math.h>
#include <stdlib.h>

#include <iostream>

using namespace std;

#include <set>

#include "../OptFrame/Solution.hpp"
//#include "../OptFrame/Util/TestSolution.hpp"

#include "../OptFrame/Heuristics/EvolutionaryAlgorithms/BRKGA.hpp"
#include "../OptFrame/Loader.hpp"
////#include "../OptFrame/Util/BuildCommand.hpp"  // TODO: return after Concepts OptFrame v4
#include "../OptFrame/Util/CheckCommand.hpp"
#include "TSP.h"

using namespace TSP;
using namespace scannerpp;

#include "../OptFrame/Util/PackTypes.hpp"



int
main(int argc, char** argv)
{
   //Loader<RepTSP, OPTFRAME_DEFAULT_ADS, SolutionTSP> optframe;
   Loader<SolutionTSP> optframe;
   TSPProblemCommand tsp;

   File* file;

   try {
      file = new File("./TSP/tsplib/berlin52.txt");
   } catch (FileNotFound& f) {
      cout << "File not found" << endl;
      return 1;
   }

   Scanner scanner(file);
   tsp.load(scanner, optframe.factory, optframe.dictionary, optframe.ldictionary);

   /*
	FILE* outf = fopen("berlin52.mtx","w");
	fprintf(outf, "%d\n", tsp.p->n);
	for(unsigned i=0; i<tsp.p->n; i++) {
		for(unsigned j=0; j<tsp.p->n; j++)
			fprintf(outf, "%d\t",int(100*(*tsp.p->dist)(i,j)));
		fprintf(outf, "\n");
	}

	fclose(outf);
	exit(1);
	*/

   bool check_verbose = false;
   CheckCommand<RepTSP, OPTFRAME_DEFAULT_ADS, SolutionTSP> check(check_verbose);

   RandGenMersenneTwister rg(0);
   RandomInitialSolutionTSP random(tsp.p, rg);
   NearestNeighborConstructive cnn(tsp.p, rg);
   ConstructiveBestInsertion cbi(tsp.p, rg);
   TSPEvaluator eval(tsp.p);
   NSEnumSwap enumswap(tsp.p, rg);

   NSSeqTSP2Opt<int, OPTFRAME_DEFAULT_ADS, SolutionTSP, DeltaMoveTSP2Opt, ProblemInstance> nsseq_delta_2opt(tsp.p);
   NSSeqTSP2Opt<int> tsp2opt;
   NSSeqTSPOrOptk<int, OPTFRAME_DEFAULT_ADS, SolutionTSP, DeltaMoveTSPOrOptk, ProblemInstance> nsseq_delta_or1(1, tsp.p);
   NSSeqTSPOrOptk<int> tspor1(1);
   NSSeqTSPOrOptk<int> tspor2(2);
   NSSeqTSPOrOptk<int> tspor3(3);
   NSSeqTSPSwap<int> tspswap;

   check.add(random);
   check.add(cnn);
   check.add(cbi);
   check.add(eval);
   check.add(enumswap);
   check.add(nsseq_delta_2opt);
   check.add(tsp2opt);
   check.add(nsseq_delta_or1);
   check.add(tspor1);
   check.add(tspor2);
   check.add(tspor3);
   check.add(tspswap);

   //check.run(100, 10);

   cout << "will test BRKGA (n=" << tsp.p->n << ")" << endl;
   EvaluatorPermutationRandomKeys eprk(eval, 0, tsp.p->n - 1);
   BRKGA<RepTSP> brkga(eprk, tsp.p->n, 10000, 10, 0.4, 0.3, 0.6);

   SOSC sosc;
   pair<CopySolution<random_keys>, Evaluation<>>* r2 = brkga.search(sosc);
   r2->first.print();

   pair<Evaluation<>, CopySolution<vector<int>>*> pd = eprk.decode(r2->first.getR());
   pd.second->print();
   if (eval.verify(pd.second->getR()))
      cout << "CHECK: OK" << endl;
   pd.first.print();

   r2->second.print();
   delete r2;

   cout << "end BRKGA tests" << endl;

   // TODO: return after refactor on Concepts and OptFrame v4
   /*
   BuildCommand<RepTSP, OPTFRAME_DEFAULT_ADS, SolutionTSP> build;
   for (unsigned i = 0; i <= 7; i++) {
      stringstream ss;
      ss << "OptFrame:ComponentBuilder:LocalSearch:BI  OptFrame:Evaluator 0  OptFrame:NS:NSSeq " << i;
      string name = build.run(optframe.factory, optframe.dictionary, optframe.ldictionary, ss.str());
      cout << "BUILT: '" << name << "'" << endl;
   }
   */

   vector<LocalSearch<RepTSP>*> ns_list;
   ns_list.push_back(new BestImprovement<RepTSP>(eval, tsp2opt));
   ns_list.push_back(new BestImprovement<RepTSP>(eval, tspor1));
   ns_list.push_back(new BestImprovement<RepTSP>(eval, tspor2));
   ns_list.push_back(new BestImprovement<RepTSP>(eval, tspor3));
   ns_list.push_back(new BestImprovement<RepTSP>(eval, tspswap));
   for (unsigned i = 0; i < ns_list.size(); i++)
      ns_list[i]->setVerbose();

   VariableNeighborhoodDescent<RepTSP> VND(eval, ns_list);
   VND.setVerbose();

   ILSLPerturbationLPlus2<RepTSP> pert(eval, tsp2opt, rg);
   pert.add_ns(tspor1);
   pert.add_ns(tspor2);
   pert.add_ns(tspor3);
   pert.add_ns(tspswap);

   IteratedLocalSearchLevels<RepTSP> ils(eval, random, VND, pert, 3, 2);
   //ils.setMessageLevel(4);
   ils.setVerbose();
   if (ils.information)
      cout << "infomation is on for ILS" << endl;

   cout << "will run ils" << endl;
   Timer tim;
   SOSC soscILS;
   soscILS.timelimit = 1000;
   soscILS.target_f = 0;
   pair<CopySolution<RepTSP>, Evaluation<>>& psol = *ils.search(soscILS, NULL, NULL);
   cout << tim.now() << " secs" << endl;

   psol.first.print();
   psol.second.print();

   // ===========

   for (unsigned i = 0; i < ns_list.size(); i++)
      delete ns_list[i];

   vector<NS<RepTSP>*> v_ns;
   vector<NSSeq<RepTSP>*> v_nsseq;
   v_nsseq.push_back(&tsp2opt);
   v_nsseq.push_back(&tspor1);
   v_nsseq.push_back(&tspor2);
   v_nsseq.push_back(&tspor3);
   v_nsseq.push_back(&tspswap);
   for (unsigned i = 0; i < v_nsseq.size(); i++)
      v_ns.push_back(v_nsseq[i]);

   BasicVNS<RepTSP> vns(eval, random, v_ns, v_nsseq);
   vns.setMessageLevel(3); // INFORMATION
   SOSC soscVNS;
   soscVNS.timelimit = 0;
   soscVNS.target_f = 8000;
   pair<CopySolution<RepTSP>, Evaluation<>>& psol2 = *vns.search(sosc, NULL, NULL);
   psol2.first.print();
   psol2.second.print();

   // Remember the old times...
   /*
	 echo building VND
	 define vnd_list [ OptFrame:LocalSearch: 0 ,  OptFrame:LocalSearch: 1, OptFrame:LocalSearch: 2, OptFrame:LocalSearch: 3 ]
	 component.create_list $vnd_list OptFrame:LocalSearch: comp_vnd_list
	 build OptFrame:LocalSearch:VND   $Evaluator 0   $comp_vnd_list   vnd

	 %component.list

	 echo building ILS
	 build OptFrame:ComponentBuilder:SingleObjSearch:ILS:ILSLevels   $Evaluator 0    $Constructive 0    $vnd   OptFrame:ILS:LevelPert:LPlus2 0    100    8  meu_ils

	 test 2 3 7000 7000   $Evaluator 0   $meu_ils   output.txt   solucao_saida

	 evaluate $Evaluator 0 $solucao_saida
	 */

   cout << "Program ended successfully" << endl;

   return 0;
}
